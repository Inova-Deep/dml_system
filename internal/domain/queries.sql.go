// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package domain

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignUserRole = `-- name: AssignUserRole :exec
INSERT INTO
    user_rbac_roles (
        tenant_id,
        user_id,
        role_id,
        business_unit_id,
        department_id,
        granted_by_user_id
    )
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (
    tenant_id,
    user_id,
    role_id,
    business_unit_id,
    department_id
) DO NOTHING
`

type AssignUserRoleParams struct {
	TenantID        pgtype.UUID `json:"tenant_id"`
	UserID          pgtype.UUID `json:"user_id"`
	RoleID          pgtype.UUID `json:"role_id"`
	BusinessUnitID  pgtype.UUID `json:"business_unit_id"`
	DepartmentID    pgtype.UUID `json:"department_id"`
	GrantedByUserID pgtype.UUID `json:"granted_by_user_id"`
}

func (q *Queries) AssignUserRole(ctx context.Context, arg AssignUserRoleParams) error {
	_, err := q.db.Exec(ctx, assignUserRole,
		arg.TenantID,
		arg.UserID,
		arg.RoleID,
		arg.BusinessUnitID,
		arg.DepartmentID,
		arg.GrantedByUserID,
	)
	return err
}

const countAuditLogs = `-- name: CountAuditLogs :one
SELECT count(*)
FROM audit_logs
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR entity_type = $2::text
    )
    AND (
        $3::text = ''
        OR action = $3::text
    )
`

type CountAuditLogsParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	EntityType string      `json:"entity_type"`
	Action     string      `json:"action"`
}

func (q *Queries) CountAuditLogs(ctx context.Context, arg CountAuditLogsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogs, arg.TenantID, arg.EntityType, arg.Action)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBusinessUnits = `-- name: CountBusinessUnits :one
SELECT count(*)
FROM business_units
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR name ILIKE '%' || $2::text || '%'
        OR code ILIKE '%' || $2::text || '%'
    )
`

type CountBusinessUnitsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
}

func (q *Queries) CountBusinessUnits(ctx context.Context, arg CountBusinessUnitsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countBusinessUnits, arg.TenantID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDepartments = `-- name: CountDepartments :one
SELECT count(*)
FROM departments
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR name ILIKE '%' || $2::text || '%'
        OR code ILIKE '%' || $2::text || '%'
    )
`

type CountDepartmentsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
}

func (q *Queries) CountDepartments(ctx context.Context, arg CountDepartmentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDepartments, arg.TenantID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEmployees = `-- name: CountEmployees :one
SELECT count(*)
FROM employees
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR first_name ILIKE '%' || $2::text || '%'
        OR last_name ILIKE '%' || $2::text || '%'
        OR display_name ILIKE '%' || $2::text || '%'
        OR work_email ILIKE '%' || $2::text || '%'
    )
`

type CountEmployeesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
}

func (q *Queries) CountEmployees(ctx context.Context, arg CountEmployeesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEmployees, arg.TenantID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJobTitles = `-- name: CountJobTitles :one
SELECT count(*)
FROM job_titles
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR name ILIKE '%' || $2::text || '%'
        OR code ILIKE '%' || $2::text || '%'
    )
`

type CountJobTitlesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
}

func (q *Queries) CountJobTitles(ctx context.Context, arg CountJobTitlesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countJobTitles, arg.TenantID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT count(*)
FROM users
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR email ILIKE '%' || $2::text || '%'
        OR display_name ILIKE '%' || $2::text || '%'
    )
`

type CountUsersParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
}

func (q *Queries) CountUsers(ctx context.Context, arg CountUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, arg.TenantID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBusinessUnit = `-- name: CreateBusinessUnit :one
INSERT INTO
    business_units (id, tenant_id, code, name)
VALUES ($1, $2, $3, $4)
RETURNING
    id, tenant_id, code, name, is_active, created_at, updated_at
`

type CreateBusinessUnitParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Code     pgtype.Text `json:"code"`
	Name     string      `json:"name"`
}

func (q *Queries) CreateBusinessUnit(ctx context.Context, arg CreateBusinessUnitParams) (BusinessUnit, error) {
	row := q.db.QueryRow(ctx, createBusinessUnit,
		arg.ID,
		arg.TenantID,
		arg.Code,
		arg.Name,
	)
	var i BusinessUnit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Name,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDepartment = `-- name: CreateDepartment :one
INSERT INTO
    departments (
        id,
        tenant_id,
        parent_department_id,
        code,
        name
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING
    id, tenant_id, parent_department_id, code, name, is_active, created_at, updated_at
`

type CreateDepartmentParams struct {
	ID                 pgtype.UUID `json:"id"`
	TenantID           pgtype.UUID `json:"tenant_id"`
	ParentDepartmentID pgtype.UUID `json:"parent_department_id"`
	Code               pgtype.Text `json:"code"`
	Name               string      `json:"name"`
}

func (q *Queries) CreateDepartment(ctx context.Context, arg CreateDepartmentParams) (Department, error) {
	row := q.db.QueryRow(ctx, createDepartment,
		arg.ID,
		arg.TenantID,
		arg.ParentDepartmentID,
		arg.Code,
		arg.Name,
	)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ParentDepartmentID,
		&i.Code,
		&i.Name,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO
    employees (
        id,
        tenant_id,
        employee_no,
        first_name,
        last_name,
        display_name,
        work_email,
        business_unit_id,
        department_id,
        job_title_id,
        manager_id
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11
    )
RETURNING
    id, tenant_id, employee_no, first_name, last_name, display_name, work_email, status, is_active, created_at, updated_at, business_unit_id, department_id, job_title_id, manager_id
`

type CreateEmployeeParams struct {
	ID             pgtype.UUID `json:"id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
	EmployeeNo     string      `json:"employee_no"`
	FirstName      string      `json:"first_name"`
	LastName       string      `json:"last_name"`
	DisplayName    pgtype.Text `json:"display_name"`
	WorkEmail      pgtype.Text `json:"work_email"`
	BusinessUnitID pgtype.UUID `json:"business_unit_id"`
	DepartmentID   pgtype.UUID `json:"department_id"`
	JobTitleID     pgtype.UUID `json:"job_title_id"`
	ManagerID      pgtype.UUID `json:"manager_id"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.ID,
		arg.TenantID,
		arg.EmployeeNo,
		arg.FirstName,
		arg.LastName,
		arg.DisplayName,
		arg.WorkEmail,
		arg.BusinessUnitID,
		arg.DepartmentID,
		arg.JobTitleID,
		arg.ManagerID,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeNo,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.WorkEmail,
		&i.Status,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BusinessUnitID,
		&i.DepartmentID,
		&i.JobTitleID,
		&i.ManagerID,
	)
	return i, err
}

const createJobTitle = `-- name: CreateJobTitle :one
INSERT INTO
    job_titles (
        id,
        tenant_id,
        code,
        name,
        grade
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING
    id, tenant_id, code, name, grade, is_active, created_at, updated_at
`

type CreateJobTitleParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
	Code     pgtype.Text `json:"code"`
	Name     string      `json:"name"`
	Grade    pgtype.Text `json:"grade"`
}

func (q *Queries) CreateJobTitle(ctx context.Context, arg CreateJobTitleParams) (JobTitle, error) {
	row := q.db.QueryRow(ctx, createJobTitle,
		arg.ID,
		arg.TenantID,
		arg.Code,
		arg.Name,
		arg.Grade,
	)
	var i JobTitle
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Name,
		&i.Grade,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO
    rbac_roles (
        id,
        tenant_id,
        code,
        name,
        description
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING
    id, tenant_id, code, name, description, is_active, created_at, updated_at
`

type CreateRoleParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Code        string      `json:"code"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (RbacRole, error) {
	row := q.db.QueryRow(ctx, createRole,
		arg.ID,
		arg.TenantID,
		arg.Code,
		arg.Name,
		arg.Description,
	)
	var i RbacRole
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTenant = `-- name: CreateTenant :one
INSERT INTO
    tenants (id, code, name)
VALUES ($1, $2, $3)
RETURNING
    id, code, name, created_at
`

type CreateTenantParams struct {
	ID   pgtype.UUID `json:"id"`
	Code string      `json:"code"`
	Name string      `json:"name"`
}

func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, createTenant, arg.ID, arg.Code, arg.Name)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
    users (
        id,
        tenant_id,
        employee_id,
        email,
        display_name,
        password_hash
    )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING
    id, tenant_id, employee_id, email, display_name, password_hash, is_active, last_login_at, created_at, updated_at
`

type CreateUserParams struct {
	ID           pgtype.UUID `json:"id"`
	TenantID     pgtype.UUID `json:"tenant_id"`
	EmployeeID   pgtype.UUID `json:"employee_id"`
	Email        string      `json:"email"`
	DisplayName  pgtype.Text `json:"display_name"`
	PasswordHash pgtype.Text `json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.TenantID,
		arg.EmployeeID,
		arg.Email,
		arg.DisplayName,
		arg.PasswordHash,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.Email,
		&i.DisplayName,
		&i.PasswordHash,
		&i.IsActive,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBusinessUnit = `-- name: GetBusinessUnit :one
SELECT id, tenant_id, code, name, is_active, created_at, updated_at
FROM business_units
WHERE
    tenant_id = $1
    AND id = $2
LIMIT 1
`

type GetBusinessUnitParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) GetBusinessUnit(ctx context.Context, arg GetBusinessUnitParams) (BusinessUnit, error) {
	row := q.db.QueryRow(ctx, getBusinessUnit, arg.TenantID, arg.ID)
	var i BusinessUnit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Name,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDepartment = `-- name: GetDepartment :one
SELECT id, tenant_id, parent_department_id, code, name, is_active, created_at, updated_at FROM departments WHERE tenant_id = $1 AND id = $2 LIMIT 1
`

type GetDepartmentParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) GetDepartment(ctx context.Context, arg GetDepartmentParams) (Department, error) {
	row := q.db.QueryRow(ctx, getDepartment, arg.TenantID, arg.ID)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ParentDepartmentID,
		&i.Code,
		&i.Name,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployee = `-- name: GetEmployee :one
SELECT id, tenant_id, employee_no, first_name, last_name, display_name, work_email, status, is_active, created_at, updated_at, business_unit_id, department_id, job_title_id, manager_id FROM employees WHERE tenant_id = $1 AND id = $2 LIMIT 1
`

type GetEmployeeParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) GetEmployee(ctx context.Context, arg GetEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployee, arg.TenantID, arg.ID)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeNo,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.WorkEmail,
		&i.Status,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BusinessUnitID,
		&i.DepartmentID,
		&i.JobTitleID,
		&i.ManagerID,
	)
	return i, err
}

const getEmployeeHierarchy = `-- name: GetEmployeeHierarchy :many
WITH RECURSIVE
    employee_tree AS (
        SELECT id, tenant_id, employee_no, first_name, last_name, display_name, work_email, status, is_active, created_at, updated_at, business_unit_id, department_id, job_title_id, manager_id
        FROM employees e1
        WHERE
            e1.tenant_id = $1
            AND e1.id = $2
        UNION ALL
        SELECT e2.id, e2.tenant_id, e2.employee_no, e2.first_name, e2.last_name, e2.display_name, e2.work_email, e2.status, e2.is_active, e2.created_at, e2.updated_at, e2.business_unit_id, e2.department_id, e2.job_title_id, e2.manager_id
        FROM
            employees e2
            INNER JOIN employee_tree et ON e2.manager_id = et.id
        WHERE
            e2.tenant_id = $1
    )
SELECT id, tenant_id, employee_no, first_name, last_name, display_name, work_email, status, is_active, created_at, updated_at, business_unit_id, department_id, job_title_id, manager_id
FROM employee_tree
`

type GetEmployeeHierarchyParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

type GetEmployeeHierarchyRow struct {
	ID             pgtype.UUID        `json:"id"`
	TenantID       pgtype.UUID        `json:"tenant_id"`
	EmployeeNo     string             `json:"employee_no"`
	FirstName      string             `json:"first_name"`
	LastName       string             `json:"last_name"`
	DisplayName    pgtype.Text        `json:"display_name"`
	WorkEmail      pgtype.Text        `json:"work_email"`
	Status         string             `json:"status"`
	IsActive       bool               `json:"is_active"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	BusinessUnitID pgtype.UUID        `json:"business_unit_id"`
	DepartmentID   pgtype.UUID        `json:"department_id"`
	JobTitleID     pgtype.UUID        `json:"job_title_id"`
	ManagerID      pgtype.UUID        `json:"manager_id"`
}

func (q *Queries) GetEmployeeHierarchy(ctx context.Context, arg GetEmployeeHierarchyParams) ([]GetEmployeeHierarchyRow, error) {
	rows, err := q.db.Query(ctx, getEmployeeHierarchy, arg.TenantID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeeHierarchyRow
	for rows.Next() {
		var i GetEmployeeHierarchyRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeNo,
			&i.FirstName,
			&i.LastName,
			&i.DisplayName,
			&i.WorkEmail,
			&i.Status,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BusinessUnitID,
			&i.DepartmentID,
			&i.JobTitleID,
			&i.ManagerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeWithDetails = `-- name: GetEmployeeWithDetails :one
SELECT
    e.id,
    e.tenant_id,
    e.employee_no,
    e.first_name,
    e.last_name,
    e.display_name,
    e.work_email,
    e.status,
    e.is_active,
    e.created_at,
    e.updated_at,
    e.business_unit_id,
    e.department_id,
    e.job_title_id,
    e.manager_id,
    bu.code AS business_unit_code,
    bu.name AS business_unit_name,
    d.code AS department_code,
    d.name AS department_name,
    jt.code AS job_title_code,
    jt.name AS job_title_name,
    jt.grade AS job_title_grade,
    m.employee_no AS manager_employee_no,
    m.first_name AS manager_first_name,
    m.last_name AS manager_last_name,
    m.display_name AS manager_display_name
FROM employees e
LEFT JOIN business_units bu ON e.business_unit_id = bu.id AND e.tenant_id = bu.tenant_id
LEFT JOIN departments d ON e.department_id = d.id AND e.tenant_id = d.tenant_id
LEFT JOIN job_titles jt ON e.job_title_id = jt.id AND e.tenant_id = jt.tenant_id
LEFT JOIN employees m ON e.manager_id = m.id AND e.tenant_id = m.tenant_id
WHERE e.tenant_id = $1 AND e.id = $2 LIMIT 1
`

type GetEmployeeWithDetailsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

type GetEmployeeWithDetailsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	EmployeeNo         string             `json:"employee_no"`
	FirstName          string             `json:"first_name"`
	LastName           string             `json:"last_name"`
	DisplayName        pgtype.Text        `json:"display_name"`
	WorkEmail          pgtype.Text        `json:"work_email"`
	Status             string             `json:"status"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	BusinessUnitID     pgtype.UUID        `json:"business_unit_id"`
	DepartmentID       pgtype.UUID        `json:"department_id"`
	JobTitleID         pgtype.UUID        `json:"job_title_id"`
	ManagerID          pgtype.UUID        `json:"manager_id"`
	BusinessUnitCode   pgtype.Text        `json:"business_unit_code"`
	BusinessUnitName   pgtype.Text        `json:"business_unit_name"`
	DepartmentCode     pgtype.Text        `json:"department_code"`
	DepartmentName     pgtype.Text        `json:"department_name"`
	JobTitleCode       pgtype.Text        `json:"job_title_code"`
	JobTitleName       pgtype.Text        `json:"job_title_name"`
	JobTitleGrade      pgtype.Text        `json:"job_title_grade"`
	ManagerEmployeeNo  pgtype.Text        `json:"manager_employee_no"`
	ManagerFirstName   pgtype.Text        `json:"manager_first_name"`
	ManagerLastName    pgtype.Text        `json:"manager_last_name"`
	ManagerDisplayName pgtype.Text        `json:"manager_display_name"`
}

func (q *Queries) GetEmployeeWithDetails(ctx context.Context, arg GetEmployeeWithDetailsParams) (GetEmployeeWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeWithDetails, arg.TenantID, arg.ID)
	var i GetEmployeeWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeNo,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.WorkEmail,
		&i.Status,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BusinessUnitID,
		&i.DepartmentID,
		&i.JobTitleID,
		&i.ManagerID,
		&i.BusinessUnitCode,
		&i.BusinessUnitName,
		&i.DepartmentCode,
		&i.DepartmentName,
		&i.JobTitleCode,
		&i.JobTitleName,
		&i.JobTitleGrade,
		&i.ManagerEmployeeNo,
		&i.ManagerFirstName,
		&i.ManagerLastName,
		&i.ManagerDisplayName,
	)
	return i, err
}

const getJobTitle = `-- name: GetJobTitle :one
SELECT id, tenant_id, code, name, grade, is_active, created_at, updated_at FROM job_titles WHERE tenant_id = $1 AND id = $2 LIMIT 1
`

type GetJobTitleParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) GetJobTitle(ctx context.Context, arg GetJobTitleParams) (JobTitle, error) {
	row := q.db.QueryRow(ctx, getJobTitle, arg.TenantID, arg.ID)
	var i JobTitle
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Name,
		&i.Grade,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT id, tenant_id, code, name, description, is_active, created_at, updated_at FROM rbac_roles WHERE tenant_id = $1 AND id = $2 LIMIT 1
`

type GetRoleParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) GetRole(ctx context.Context, arg GetRoleParams) (RbacRole, error) {
	row := q.db.QueryRow(ctx, getRole, arg.TenantID, arg.ID)
	var i RbacRole
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenant = `-- name: GetTenant :one
SELECT id, code, name, created_at FROM tenants WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTenant(ctx context.Context, id pgtype.UUID) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenant, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.CreatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, tenant_id, employee_id, email, display_name, password_hash, is_active, last_login_at, created_at, updated_at FROM users WHERE tenant_id = $1 AND id = $2 LIMIT 1
`

type GetUserParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (User, error) {
	row := q.db.QueryRow(ctx, getUser, arg.TenantID, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.Email,
		&i.DisplayName,
		&i.PasswordHash,
		&i.IsActive,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, tenant_id, employee_id, email, display_name, password_hash, is_active, last_login_at, created_at, updated_at FROM users WHERE tenant_id = $1 AND email = $2 LIMIT 1
`

type GetUserByEmailParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Email    string      `json:"email"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, arg.TenantID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.Email,
		&i.DisplayName,
		&i.PasswordHash,
		&i.IsActive,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserForLogin = `-- name: GetUserForLogin :one
SELECT id, tenant_id, employee_id, email, display_name, password_hash, is_active, last_login_at, created_at, updated_at FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserForLogin(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserForLogin, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.EmployeeID,
		&i.Email,
		&i.DisplayName,
		&i.PasswordHash,
		&i.IsActive,
		&i.LastLoginAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.code
FROM
    user_rbac_roles ur
    JOIN rbac_roles r ON ur.role_id = r.id
    AND ur.tenant_id = r.tenant_id
WHERE
    ur.tenant_id = $1
    AND ur.user_id = $2
`

type GetUserRolesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetUserRoles(ctx context.Context, arg GetUserRolesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserRoles, arg.TenantID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, err
		}
		items = append(items, code)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAuditLog = `-- name: InsertAuditLog :one
INSERT INTO
    audit_logs (
        id,
        tenant_id,
        actor_id,
        action,
        entity_type,
        entity_id,
        changes
    )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING
    id, tenant_id, actor_id, action, entity_type, entity_id, changes, created_at
`

type InsertAuditLogParams struct {
	ID         pgtype.UUID `json:"id"`
	TenantID   pgtype.UUID `json:"tenant_id"`
	ActorID    pgtype.UUID `json:"actor_id"`
	Action     string      `json:"action"`
	EntityType string      `json:"entity_type"`
	EntityID   pgtype.UUID `json:"entity_id"`
	Changes    []byte      `json:"changes"`
}

func (q *Queries) InsertAuditLog(ctx context.Context, arg InsertAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, insertAuditLog,
		arg.ID,
		arg.TenantID,
		arg.ActorID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.Changes,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ActorID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.Changes,
		&i.CreatedAt,
	)
	return i, err
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, tenant_id, actor_id, action, entity_type, entity_id, changes, created_at
FROM audit_logs
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR entity_type = $2::text
    )
    AND (
        $3::text = ''
        OR action = $3::text
    )
ORDER BY created_at DESC
LIMIT $5
OFFSET
    $4
`

type ListAuditLogsParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	EntityType string      `json:"entity_type"`
	Action     string      `json:"action"`
	Offset     int32       `json:"offset"`
	Limit      int32       `json:"limit"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogs,
		arg.TenantID,
		arg.EntityType,
		arg.Action,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ActorID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.Changes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBusinessUnits = `-- name: ListBusinessUnits :many
SELECT id, tenant_id, code, name, is_active, created_at, updated_at
FROM business_units
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR name ILIKE '%' || $2::text || '%'
        OR code ILIKE '%' || $2::text || '%'
    )
ORDER BY name
LIMIT $4
OFFSET
    $3
`

type ListBusinessUnitsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) ListBusinessUnits(ctx context.Context, arg ListBusinessUnitsParams) ([]BusinessUnit, error) {
	rows, err := q.db.Query(ctx, listBusinessUnits,
		arg.TenantID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BusinessUnit
	for rows.Next() {
		var i BusinessUnit
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Code,
			&i.Name,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDepartments = `-- name: ListDepartments :many
SELECT id, tenant_id, parent_department_id, code, name, is_active, created_at, updated_at
FROM departments
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR name ILIKE '%' || $2::text || '%'
        OR code ILIKE '%' || $2::text || '%'
    )
ORDER BY name
LIMIT $4
OFFSET
    $3
`

type ListDepartmentsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) ListDepartments(ctx context.Context, arg ListDepartmentsParams) ([]Department, error) {
	rows, err := q.db.Query(ctx, listDepartments,
		arg.TenantID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Department
	for rows.Next() {
		var i Department
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ParentDepartmentID,
			&i.Code,
			&i.Name,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployees = `-- name: ListEmployees :many
SELECT id, tenant_id, employee_no, first_name, last_name, display_name, work_email, status, is_active, created_at, updated_at, business_unit_id, department_id, job_title_id, manager_id
FROM employees
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR first_name ILIKE '%' || $2::text || '%'
        OR last_name ILIKE '%' || $2::text || '%'
        OR display_name ILIKE '%' || $2::text || '%'
        OR work_email ILIKE '%' || $2::text || '%'
    )
ORDER BY last_name, first_name
LIMIT $4
OFFSET
    $3
`

type ListEmployeesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) ListEmployees(ctx context.Context, arg ListEmployeesParams) ([]Employee, error) {
	rows, err := q.db.Query(ctx, listEmployees,
		arg.TenantID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeNo,
			&i.FirstName,
			&i.LastName,
			&i.DisplayName,
			&i.WorkEmail,
			&i.Status,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BusinessUnitID,
			&i.DepartmentID,
			&i.JobTitleID,
			&i.ManagerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeesWithDetails = `-- name: ListEmployeesWithDetails :many
SELECT
    e.id,
    e.tenant_id,
    e.employee_no,
    e.first_name,
    e.last_name,
    e.display_name,
    e.work_email,
    e.status,
    e.is_active,
    e.created_at,
    e.updated_at,
    e.business_unit_id,
    e.department_id,
    e.job_title_id,
    e.manager_id,
    bu.code AS business_unit_code,
    bu.name AS business_unit_name,
    d.code AS department_code,
    d.name AS department_name,
    jt.code AS job_title_code,
    jt.name AS job_title_name,
    jt.grade AS job_title_grade,
    m.employee_no AS manager_employee_no,
    m.first_name AS manager_first_name,
    m.last_name AS manager_last_name,
    m.display_name AS manager_display_name
FROM employees e
LEFT JOIN business_units bu ON e.business_unit_id = bu.id AND e.tenant_id = bu.tenant_id
LEFT JOIN departments d ON e.department_id = d.id AND e.tenant_id = d.tenant_id
LEFT JOIN job_titles jt ON e.job_title_id = jt.id AND e.tenant_id = jt.tenant_id
LEFT JOIN employees m ON e.manager_id = m.id AND e.tenant_id = m.tenant_id
WHERE
    e.tenant_id = $1
    AND (
        $2::text = ''
        OR e.first_name ILIKE '%' || $2::text || '%'
        OR e.last_name ILIKE '%' || $2::text || '%'
        OR e.display_name ILIKE '%' || $2::text || '%'
        OR e.work_email ILIKE '%' || $2::text || '%'
    )
ORDER BY e.last_name, e.first_name
LIMIT $4
OFFSET
    $3
`

type ListEmployeesWithDetailsParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

type ListEmployeesWithDetailsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	TenantID           pgtype.UUID        `json:"tenant_id"`
	EmployeeNo         string             `json:"employee_no"`
	FirstName          string             `json:"first_name"`
	LastName           string             `json:"last_name"`
	DisplayName        pgtype.Text        `json:"display_name"`
	WorkEmail          pgtype.Text        `json:"work_email"`
	Status             string             `json:"status"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	BusinessUnitID     pgtype.UUID        `json:"business_unit_id"`
	DepartmentID       pgtype.UUID        `json:"department_id"`
	JobTitleID         pgtype.UUID        `json:"job_title_id"`
	ManagerID          pgtype.UUID        `json:"manager_id"`
	BusinessUnitCode   pgtype.Text        `json:"business_unit_code"`
	BusinessUnitName   pgtype.Text        `json:"business_unit_name"`
	DepartmentCode     pgtype.Text        `json:"department_code"`
	DepartmentName     pgtype.Text        `json:"department_name"`
	JobTitleCode       pgtype.Text        `json:"job_title_code"`
	JobTitleName       pgtype.Text        `json:"job_title_name"`
	JobTitleGrade      pgtype.Text        `json:"job_title_grade"`
	ManagerEmployeeNo  pgtype.Text        `json:"manager_employee_no"`
	ManagerFirstName   pgtype.Text        `json:"manager_first_name"`
	ManagerLastName    pgtype.Text        `json:"manager_last_name"`
	ManagerDisplayName pgtype.Text        `json:"manager_display_name"`
}

func (q *Queries) ListEmployeesWithDetails(ctx context.Context, arg ListEmployeesWithDetailsParams) ([]ListEmployeesWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listEmployeesWithDetails,
		arg.TenantID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEmployeesWithDetailsRow
	for rows.Next() {
		var i ListEmployeesWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeNo,
			&i.FirstName,
			&i.LastName,
			&i.DisplayName,
			&i.WorkEmail,
			&i.Status,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BusinessUnitID,
			&i.DepartmentID,
			&i.JobTitleID,
			&i.ManagerID,
			&i.BusinessUnitCode,
			&i.BusinessUnitName,
			&i.DepartmentCode,
			&i.DepartmentName,
			&i.JobTitleCode,
			&i.JobTitleName,
			&i.JobTitleGrade,
			&i.ManagerEmployeeNo,
			&i.ManagerFirstName,
			&i.ManagerLastName,
			&i.ManagerDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobTitles = `-- name: ListJobTitles :many
SELECT id, tenant_id, code, name, grade, is_active, created_at, updated_at
FROM job_titles
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR name ILIKE '%' || $2::text || '%'
        OR code ILIKE '%' || $2::text || '%'
    )
ORDER BY name
LIMIT $4
OFFSET
    $3
`

type ListJobTitlesParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) ListJobTitles(ctx context.Context, arg ListJobTitlesParams) ([]JobTitle, error) {
	rows, err := q.db.Query(ctx, listJobTitles,
		arg.TenantID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobTitle
	for rows.Next() {
		var i JobTitle
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Code,
			&i.Name,
			&i.Grade,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, tenant_id, code, name, description, is_active, created_at, updated_at FROM rbac_roles WHERE tenant_id = $1 ORDER BY name
`

func (q *Queries) ListRoles(ctx context.Context, tenantID pgtype.UUID) ([]RbacRole, error) {
	rows, err := q.db.Query(ctx, listRoles, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RbacRole
	for rows.Next() {
		var i RbacRole
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenants = `-- name: ListTenants :many
SELECT id, code, name, created_at FROM tenants ORDER BY name
`

func (q *Queries) ListTenants(ctx context.Context) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, listTenants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tenant
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, tenant_id, employee_id, email, display_name, password_hash, is_active, last_login_at, created_at, updated_at
FROM users
WHERE
    tenant_id = $1
    AND (
        $2::text = ''
        OR email ILIKE '%' || $2::text || '%'
        OR display_name ILIKE '%' || $2::text || '%'
    )
ORDER BY email
LIMIT $4
OFFSET
    $3
`

type ListUsersParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Search   string      `json:"search"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers,
		arg.TenantID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.EmployeeID,
			&i.Email,
			&i.DisplayName,
			&i.PasswordHash,
			&i.IsActive,
			&i.LastLoginAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeUserRole = `-- name: RevokeUserRole :exec
DELETE FROM user_rbac_roles
WHERE
    tenant_id = $1
    AND user_id = $2
    AND role_id = $3
`

type RevokeUserRoleParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
	RoleID   pgtype.UUID `json:"role_id"`
}

func (q *Queries) RevokeUserRole(ctx context.Context, arg RevokeUserRoleParams) error {
	_, err := q.db.Exec(ctx, revokeUserRole, arg.TenantID, arg.UserID, arg.RoleID)
	return err
}
